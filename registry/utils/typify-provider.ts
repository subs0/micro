import fs from 'fs'
import { quicktype, InputData, jsonInputForTargetLanguage } from 'quicktype-core'
import { ts_interface_prop_K_V_groups } from './regex'
import { md2json } from './md2json'

/* ðŸ”¥ NEW APPROACH WITH THE ENTIRE PROVIDER PAYLOAD ðŸ”¥

Next steps:
- consider how to handle nested duplicate keys (if any - inspect)
- develop `conformer` function:
    - reformat output payloads to conform to terraform JSON spec
        - from { name: { resource: { aws_lambda_function: { ... } } } } (ensures unique names)
        - to { resource: { aws_lambda_function: { name: { ... } } } }
        - or { resource: { aws_lambda_function: [ { name: { ... } } ] } }
        - while preserving the order of the keys (test both approaches)
    - generates the '${data.lambda_function.name.function_arn}' paths on call
- prepend '(Output only)' to all attrs value strings (tb comments)

*/

export const cutBang = (str: string) => str.replace('!', '')
/**
 * TODO: Add (Output) & or convert v to `${...path.REGEXREPLACER...}` for all
 */
export const trimBangs = (obj: object) =>
    Object.entries(obj).reduce((a, c) => {
        const [k, v] = c
        if (typeof v === 'object') {
            return { ...a, [cutBang(k)]: trimBangs(v) }
        } else if (typeof v === 'string') {
            return { ...a, [cutBang(k)]: v }
        } else return a
    }, {})

const hasBangs = (str: string) => str.includes('!')
const isEmpty = (obj: object) => obj.constructor === Object && Object.keys(obj).length === 0
/**
 * Tailored to the input requirements of quicktype, this function removes all
 * optional properties from a JSON objection (denoted by a '!' on the key) and
 * returns a new object with only the required properties.
 *
 * This payload is paired with a payload containing all properties, and the
 * result allows quicktype to generate a typescript interface properly annotated
 * optional interface properties.
 */
export const isolateRequiredProps = (args: object) => {
    const required = Object.entries(args).reduce((a, c) => {
        const [k, v] = c
        if (hasBangs(k)) {
            if (typeof v === 'object') {
                return {
                    ...a,
                    ...(!isEmpty(isolateRequiredProps(v))
                        ? { [cutBang(k)]: isolateRequiredProps(v) }
                        : {}),
                }
            } else if (typeof v === 'string') {
                return { ...a, [cutBang(k)]: v }
            } else return a
        } else return a
    }, {})
    return required
}

/*
const target_id = '3198562'
const test_file = fs.readFileSync(`registry/docs/terraform-provider-aws/${target_id}.json`, 'utf8')
const test_payload = JSON.parse(test_file)
const test_md = test_payload['data']['attributes']['content']
const test_json = md2json(test_md)
const isolated = isolateRequiredProps(test_json["args"])
console.log('isolated:', isolated)
*/

/**
 * Quicktype produces code along with type definitions. This function grabs only
 * the type definitions from the output by:
 * 1. targetting the lines starting after the last line that starts with '//'
 * 2. keeps following lines that don't start with '//' (first section = types)
 * 3. stops at the first line that follows the kept lines that starts with '//'
 */
const pullTypeLines = (lines: string[]) => {
    let procede = true
    const firstNonComment = lines.findIndex((l) => !l.startsWith('//'))
    const todo = lines.slice(firstNonComment + 1)
    return todo.reduce(
        (a, c) => {
            if (procede) {
                if (c.startsWith('//')) {
                    procede = false
                    return a
                } else return [...a, c]
            } else return a
        },
        ['']
    )
}

/**
 * Takes the type-only lines generated by quicktype and injects comments from
 * the JSON payload generated from the upstream markdown file into the
 * typescript interface.
 */
const injectDefsForMatchingProps = (typeLines: string[], payload: {}, indent = 4) => {
    const flattenObject = (obj) => {
        const keys = Object.keys(obj)
        return keys.reduce((a, c) => {
            const value = obj[c]
            if (typeof value === 'object') {
                return { ...a, ...flattenObject(value) }
            } else return { ...a, [c]: value }
        }, {})
    }
    //TODO : consider the effect of nested duplicate keys : TODO
    const dict = flattenObject(payload)
    return typeLines
        .reduce(
            (a, c) => {
                // replace 'string' with 'any' for now
                c = c.replace('string', 'any')
                const groups = c.match(ts_interface_prop_K_V_groups)
                const [key, value] = groups ? [...groups].slice(1) : []
                if (key && value) {
                    if (dict[key]) {
                        return [...a, `${' '.repeat(indent)}/** ${dict[key]} */`, c]
                    } else return [...a, c]
                } else return [...a, c]
            },
            ['']
        )
        .join('\n')
        .trim()
}

const escapedTfTemplateEx = (name) => `\${data.lambda_function.${name}.function_arn}`
console.log(escapedTfTemplateEx('name')) //? => works

/**
 * This is a refactor of the above function to handle the new payload format...
 * Algorithm:
 * - a cursor is kept to track the current path into the payload given where we are in the typeLines
 *    - the cursor is an array of strings, which are popped and pushed as we traverse the payload
 *    - the termination point of the cursor is when the value is 'string' or 'any'
 */
const injectDefsForMatchingProps2 = (typeLines: string[], payload: {}, indent = 4) => {
    let areTypeLines = false
    let cursor = []
    const lines = typeLines.reduce((a, c) => {
        // if line begins with //
        return a
    }, [])
}

interface ProviderJson {
    data: object
    resource: object
}
const getSamplesFromProviderForQT = async (
    provider = 'terraform-provider-aws',
    refresh = false,
    path = 'registry/json'
) => {
    const jsonPath = `${path}/${provider}`
    const samplesPaths = [0, 1, 2, 3].map((x) => `${jsonPath}/sample${x}.json`)
    const samplesExist = samplesPaths.map((x) => fs.existsSync(x))
    if (!refresh && samplesExist.every((x) => x)) {
        const samples = samplesPaths.map((x) => fs.readFileSync(x, 'utf8'))
        return samples
    } else {
        const required = (cat: object) =>
            Object.entries(cat).reduce((a, c) => {
                const [k, v] = c
                const { args } = v
                return { ...a, [k]: isolateRequiredProps(args) }
            }, {})
        const complete = (cat: object) =>
            Object.entries(cat).reduce((a, c) => {
                const [k, v] = c
                const { args, attrs } = v
                return { ...a, [k]: trimBangs({ ...args, ...attrs }) }
            }, {})

        const inputJson = JSON.parse(fs.readFileSync(`${jsonPath}.json`, 'utf8'))
        const { data, resource } = inputJson as ProviderJson
        const sample0 = {}
        const sample1 = { data: {}, resource: {} }
        const sample2 = { data: required(data), resource: required(resource) }
        const sample3 = { data: complete(data), resource: complete(resource) }
        const allSamples = [sample0, sample1, sample2, sample3]

        if (!fs.existsSync(jsonPath)) {
            fs.mkdirSync(jsonPath)
        }
        allSamples.forEach((x, i) => fs.writeFileSync(samplesPaths[i], JSON.stringify(x, null, 4)))
        return allSamples.map((x) => JSON.stringify(x))
    }
}

const getQtTypesFromProviderSamples = async (
    samples: string[],
    provider = 'terraform-provider-aws',
    targetLanguage = 'typescript',
    indent = 4
) => {
    const jsonInput = jsonInputForTargetLanguage(targetLanguage)
    await jsonInput.addSource({
        name: provider,
        samples,
        description: 'some description goes here',
    })
    const inputData = new InputData()
    inputData.addInput(jsonInput)
    const { lines, ...rest } = await quicktype({
        inputData,
        lang: targetLanguage,
        alphabetizeProperties: false,
        indentation: ' '.repeat(indent),
        checkProvenance: true,
        //debugPrintGatherNames: true,
        //debugPrintGraph: true,
        inferEnums: false,
        allPropertiesOptional: false,
        inferBooleanStrings: false,
        inferDateTimes: false,
        inferIntegerStrings: false,
        inferMaps: false,
        inferUuids: false,
    })
    //console.log('rest:', rest)
    return lines
}

export const generateTypesForProvider = async (
    provider = 'terraform-provider-aws',
    refresh = false,
    jsonPath = 'registry/json',
    typePath = 'registry/types'
) => {
    const typesPath = `./${typePath}/${provider}/types.ts`
    if (!refresh && fs.existsSync(typesPath)) {
        return fs.readFileSync(typesPath, 'utf8')
    }
    const sampleFiles = await getSamplesFromProviderForQT(provider, refresh, jsonPath)
    console.log('Sample count:', sampleFiles.length)
    const typeLines = await getQtTypesFromProviderSamples(sampleFiles, provider)
    // write them to disk
    fs.writeFileSync(typesPath, typeLines.join('\n'))
    return typeLines
}

// TEST
generateTypesForProvider('terraform-provider-aws', true)
