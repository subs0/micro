import fs from 'fs'
import {
    quicktype,
    InputData,
    jsonInputForTargetLanguage,
    JSONSchemaInput,
    FetchingJSONSchemaStore,
} from 'quicktype-core'
import { ts_interface_prop_K_V_groups } from './regex'
import { md2json } from './md2json'

export const cutBang = (str: string) => str.replace('!', '')
export const trimBangs = (obj: object) =>
    Object.entries(obj).reduce((a, c) => {
        const [k, v] = c
        if (typeof v === 'object') {
            return { ...a, [cutBang(k)]: trimBangs(v) }
        } else if (typeof v === 'string') {
            return { ...a, [cutBang(k)]: v }
        } else return a
    }, {})

const hasBangs = (str: string) => str.includes('!')
const isEmpty = (obj: object) => obj.constructor === Object && Object.keys(obj).length === 0
/**
 * Tailored to the input requirements of quicktype, this function removes all
 * optional properties from a JSON objection (denoted by a '!' on the key) and
 * returns a new object with only the required properties.
 *
 * This payload is paired with a payload containing all properties, and the
 * result allows quicktype to generate a typescript interface properly annotated
 * optional interface properties.
 */
export const isolateRequiredProps = (args: object) => {
    const required = Object.entries(args).reduce((a, c) => {
        const [k, v] = c
        if (hasBangs(k)) {
            if (typeof v === 'object') {
                return {
                    ...a,
                    ...(!isEmpty(isolateRequiredProps(v))
                        ? { [cutBang(k)]: isolateRequiredProps(v) }
                        : {}),
                }
            } else if (typeof v === 'string') {
                return { ...a, [cutBang(k)]: v }
            } else return a
        } else return a
    }, {})
    return required
}

/**
 * converts markdown to a JSON object, whos signature is converted by quicktype
 * to generate a fully qualified typescript interface for that object:
 * export interface Type { category: Category[] }
 * export interface Category { type: TypeClass }
 * export interface TypeClass { key: value; ... }
 */
const genTypeTree = (allProps: object, typeName: string, category = 'resource') => {
    const bangArgs = allProps['args']
    const cleanArgs = trimBangs(bangArgs)

    const reqArgs = isolateRequiredProps(bangArgs)
    // ðŸ”¥ TODO: add support for Attributes (output types)
    // spread into 'args' and add "(Output)" to value
    // consider setting default outputs as paths '${data.lambda_function.function_arn}'
    const reqAttrs = allProps['attrs']
    return { [category]: [{ [typeName]: cleanArgs }, { [typeName]: reqArgs }] }
}

/**
 * Quicktype is a tool that generates typescript interfaces from JSON objects.
 * This function takes a JSON string and returns the typescript interface
 * generated by quicktype.
 */
async function quicktypeJSON(
    jsonString: string,
    typeName = 'typeName',
    targetLanguage = 'typescript'
) {
    const jsonInput = jsonInputForTargetLanguage(targetLanguage)

    // We could add multiple samples for the same desired
    // type, or many sources for other types. Here we're
    // just making one type from one piece of sample JSON.
    await jsonInput.addSource({
        name: typeName,
        samples: [jsonString],
    })

    const inputData = new InputData()
    inputData.addInput(jsonInput)

    const { lines } = await quicktype({
        inputData,
        lang: targetLanguage,
    })
    /**
     * Quicktype produces code along with type definitions. This function grabs only
     * the type definitions from the output by:
     * 1. targetting the lines starting after the last line that starts with '//'
     * 2. keeps following lines that don't start with '//' (first section = types)
     * 3. stops at the first line that follows the kept lines that starts with '//'
     */
    const pullTypeLines = (lines: string[]) => {
        let procede = true
        const firstNonComment = lines.findIndex((l) => !l.startsWith('//'))
        const todo = lines.slice(firstNonComment + 1)
        return todo.reduce(
            (a, c) => {
                if (procede) {
                    if (c.startsWith('//')) {
                        procede = false
                        return a
                    } else return [...a, c]
                } else return a
            },
            ['']
        )
    }
    return pullTypeLines(lines)
}

/**
 * Takes the type-only lines generated by quicktype and injects comments from
 * the JSON payload generated from the upstream markdown file into the
 * typescript interface.
 */
const injectDefsForMatchingProps = (typeLines: string[], payload: {}, indent = 4) => {
    const flattenObject = (obj) => {
        const keys = Object.keys(obj)
        return keys.reduce((a, c) => {
            const value = obj[c]
            if (typeof value === 'object') {
                return { ...a, ...flattenObject(value) }
            } else return { ...a, [c]: value }
        }, {})
    }
    //TODO : consider the effect of nested duplicate keys : TODO
    const dict = flattenObject(payload)
    return typeLines
        .reduce(
            (a, c) => {
                // replace 'string' with 'any' for now
                c = c.replace('string', 'any')
                const groups = c.match(ts_interface_prop_K_V_groups)
                const [key, value] = groups ? [...groups].slice(1) : []
                if (key && value) {
                    if (dict[key]) {
                        return [...a, `${' '.repeat(indent)}/** ${dict[key]} */`, c]
                    } else return [...a, c]
                } else return [...a, c]
            },
            ['']
        )
        .join('\n')
        .trim()
}

export const typifyTfPayload = async (
    allProps: object,
    typeName: string,
    category = 'resource'
) => {
    const typeTree = genTypeTree(allProps, typeName, category)
    const typeLines = await quicktypeJSON(JSON.stringify(typeTree), typeName)
    const lines = injectDefsForMatchingProps(typeLines, typeTree)
    return lines
}

//const test_md = fs.readFileSync('./repl/aws_lambda_function.md', 'utf8')
//typifyTfPayload(test_md, 'aws_lambda_function').then(console.log) //?

// ðŸ”¥ STARTING NEW APPROACH WITH THE ENTIRE PROVIDER PAYLOAD ðŸ”¥

/*
each resource/data will have 3 representations:
1. Full: all properties, including optional properties (attrs)
2. Required: only required properties and required sub-properties (e.g., 'vpc_ipam_pools.filter')
3. empty: only the type name (e.g., 'cloudwatch_log_group') -> makes the type optional

the entire provider payload will have the following shape
sample 0: {}
sample 1: {
    data: {}
    resource: {}
}
sample 2: {
    data: { lambda_function: { ...required props... }, ... },
    resource: { lambda_function: { ...required props... }, ... }
}
sample 3: {
    data: { lambda_function: { ...all props including attrs... }, ... },
    resource: { lambda_function: { ...all props including attrs ... }, ... }
}
...result:
export interface TypeName {â€ˆ
    data?:     Data;â€ˆ
    resource?: Data;â€ˆ
}â€ˆ
â€ˆ
export interface Data {â€ˆ
    lambda_function?: LambdaFunction;â€ˆ
}â€ˆ
â€ˆ
export interface LambdaFunction {â€ˆ
    required:  string;â€ˆ
    optional?: string;â€ˆ
}â€ˆ
...

PROVEN: if you want a child property to be required, 
they must be present whenever the parent is, 
else it will be marked as optional

Next steps:
- add (Output) to all attrs value strings (tb comments)
- consider how to handle nested duplicate keys (if any - inspect)
- develop xf'er fn to reformat output payloads to conform to terraform JSON spec
    - from { name: { resource: { aws_lambda_function: { ... } } } }
    - to { resource: { aws_lambda_function: { name: { ... } } } }
    - or { resource: { aws_lambda_function: [ { name: { ... } } ] } }
    - while preserving the order of the keys (test both approaches)
*/
const generateTypesForProvider = async (
    provider: string = 'terraform-aws-provider',
    path = 'registry/json'
) => {
    // read in the json file for the provider
    const json = JSON.parse(fs.readFileSync(`./${path}/${provider}.json`, 'utf8'))
    const generateSampelsForQT = (json: object) => {
        const { data, resource } = json
    }
}
